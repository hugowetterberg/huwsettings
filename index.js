// Generated by CoffeeScript 1.7.1
(function() {
  var evaluateConditions, hasValue, lib, operators, processValue;

  lib = {
    fs: require('fs'),
    jsyaml: require('js-yaml')
  };

  processValue = function(buckets, value) {
    var key, name;
    key = value.length ? value[0] : false;
    if (key && buckets[key]) {
      name = value.substring(1);
      if (name.length && name[0] === key) {
        value = name;
      } else if (buckets[key][name] != null) {
        value = buckets[key][name];
      }
    }
    return value;
  };

  hasValue = function(buckets, value) {
    var exists, key;
    key = value.length ? value[0] : false;
    exists = key !== false;
    if (key && (buckets[key] != null)) {
      exists = buckets[key][value.substring(1)] != null;
    }
    return exists;
  };

  operators = {
    is: function(buckets, a, b) {
      a = processValue(buckets, a);
      b = processValue(buckets, b);
      return a === b;
    },
    contains: function(buckets, a, b) {
      a = processValue(buckets, a);
      b = processValue(buckets, b);
      return a.indexOf(b) >= 0;
    },
    greater: function(buckets, a, b) {
      a = processValue(buckets, a);
      b = processValue(buckets, b);
      return parseFloat(a) > parseFloat(b);
    },
    greater_or_equal: function(buckets, a, b) {
      a = processValue(buckets, a);
      b = processValue(buckets, b);
      return parseFloat(a) >= parseFloat(b);
    },
    is_set: function(buckets, a, b) {
      return hasValue(buckets, b);
    }
  };

  evaluateConditions = function(buckets, conditions) {
    var argument, condition, negate, opName, result, value, _i, _len;
    result = true;
    for (_i = 0, _len = conditions.length; _i < _len; _i++) {
      condition = conditions[_i];
      value = null;
      negate = false;
      if (condition.value != null) {
        value = condition.value;
        delete condition.value;
      }
      if (condition.negate != null) {
        negate = condition.negate;
        delete condition.negate;
      }
      for (opName in condition) {
        argument = condition[opName];
        if (operators[opName] != null) {
          result = operators[opName](buckets, value, argument);
          if (negate) {
            result = !result;
          }
          if (!result) {
            break;
          }
        }
      }
    }
    return result;
  };

  exports.load = function(chain, callback) {
    var buckets, load, settings;
    buckets = {
      '<': {},
      '$': process.env
    };
    settings = {};
    load = function(file) {
      return lib.fs.readFile(file, 'utf8', function(error, yaml) {
        var doc, header, loaded;
        if (error) {
          return callback(error);
        }
        try {
          loaded = [];
          lib.jsyaml.loadAll(yaml, function(doc) {
            return loaded.push(doc);
          });
          if (loaded.length === 1) {
            exports.extend(settings, loaded[0], buckets);
          } else {
            while (loaded.length) {
              header = loaded.shift();
              doc = loaded.shift();
              exports.extendWithHeader(settings, header, doc, buckets);
            }
          }
        } catch (_error) {
          error = _error;
          return callback(error);
        }
        if (chain.length) {
          return load(chain.shift());
        } else {
          return callback(null, settings);
        }
      });
    };
    if (!Array.isArray(chain)) {
      chain = [chain];
    }
    return load(chain.shift());
  };

  exports.merge = function(chain, buckets) {
    var object, settings, _i, _len;
    settings = {};
    for (_i = 0, _len = chain.length; _i < _len; _i++) {
      object = chain[_i];
      exports.extend(settings, object);
    }
    return settings;
  };

  exports.extendWithHeader = function(settings, header, values, buckets) {
    if (!(header && (header.conditions != null)) || evaluateConditions(buckets, header.conditions)) {
      if (header && (header.state != null)) {
        exports.extend(buckets['<'], header.state, buckets);
      }
      return exports.extend(settings, values, buckets);
    }
  };

  exports.extend = function(settings, values, buckets) {
    var k, merge, v, _results;
    merge = function(key, value) {
      var next, ref, seg;
      seg = key.split('/');
      ref = settings;
      next = function() {
        var append, current, fixed_ref, k, last, seg_copy, v;
        current = seg.shift();
        append = seg.length && seg[0] === '';
        last = seg.length === 0 || (append && seg.length === 1);
        if (current === '') {
          seg_copy = seg.slice(0, seg.length);
          fixed_ref = ref;
          for (k in ref) {
            v = ref[k];
            seg.unshift(k);
            next();
            ref = fixed_ref;
            seg = seg_copy.slice(0, seg_copy.length);
          }
          return;
        }
        if (last) {
          if (append) {
            if (ref[current] != null) {
              if (!Array.isArray(ref[current])) {
                ref[current] = [ref[current]];
              }
              if (Array.isArray(value)) {
                return ref[current] = ref[current].concat(value);
              } else {
                return ref[current].push(value);
              }
            } else {
              return ref[current] = [value];
            }
          } else {
            if (typeof ref === 'object' && !Array.isArray(ref)) {
              value = processValue(buckets, value);
              return ref[current] = value;
            }
          }
        } else {
          if (ref[current] == null) {
            ref[current] = {};
          }
          ref = ref[current];
          return next();
        }
      };
      return next();
    };
    _results = [];
    for (k in values) {
      v = values[k];
      _results.push(merge(k, v));
    }
    return _results;
  };

}).call(this);
